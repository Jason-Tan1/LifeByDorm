import dotenv from 'dotenv';
import path from 'path';
import express, { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import jwt, { Secret, JwtPayload } from 'jsonwebtoken';
import mongoose from 'mongoose'; // MongoDB Connections from Node.js
import bcrypt from 'bcryptjs'; //Hide Passwords
import { OAuth2Client } from 'google-auth-library';
import rateLimit from 'express-rate-limit';
import { User, IUser } from './models/user';
import { UserReview } from './models/userreview';
import { University } from './models/universities';
import { Dorm } from './models/dorm';
import nodemailer from 'nodemailer';
import helmet from 'helmet';
import { uploadToS3 } from './s3';

// Note: express-mongo-sanitize is incompatible with Express 5 (req.query is read-only)
// MongoDB injection protection is handled by Mongoose's strict schema validation
import { 
  validate, 
  registerSchema, 
  loginSchema, 
  sendCodeSchema, 
  verifyCodeSchema, 
  googleAuthSchema, 
  dormSchema, 
  reviewSchema 
} from './validation';

dotenv.config();
console.log('Loaded secret:', process.env.ACCESS_TOKEN_SECRET ? 'âœ… Loaded' : 'âŒ Missing');

// Validate required environment variables
if (!process.env.ACCESS_TOKEN_SECRET) {
  console.error('âŒ CRITICAL: ACCESS_TOKEN_SECRET is not defined in .env file');
  process.exit(1);
}

// Admin emails (comma-separated) read from env, e.g. ADMIN_EMAILS=admin@example.com,alice@org.com
const ADMIN_EMAILS: string[] = (process.env.ADMIN_EMAILS || '').split(',').map(s => s.trim()).filter(Boolean);
console.log('Admin emails:', ADMIN_EMAILS.length ? ADMIN_EMAILS : 'none');

const app = express()

// CORS configuration - restrict to trusted origins
const ALLOWED_ORIGINS = [
  process.env.FRONTEND_URL || 'https://lifebydorm.ca',
  'http://localhost:5173',
  'http://127.0.0.1:5173',
  'http://localhost:4173',
  'http://127.0.0.1:4173',
  'http://localhost:3000'
].filter(Boolean);

app.use(cors({
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps, curl, Postman)
    if (!origin) return callback(null, true);

    // Exact match allowed origins
    if (ALLOWED_ORIGINS.indexOf(origin) !== -1) {
      return callback(null, true);
    }

    // Allow common localhost/127.0.0.1 origins in non-production (dev) environments
    if (process.env.NODE_ENV !== 'production' && origin) {
      try {
        const parsed = new URL(origin);
        const host = parsed.hostname;
        if (host === 'localhost' || host === '127.0.0.1') {
          return callback(null, true);
        }
      } catch (e) {
        // ignore parse errors and fall through to block
      }
    }

    console.warn(`ðŸš« Blocked CORS request from unauthorized origin: ${origin}`);
    callback(new Error('Not allowed by CORS'));
  },
  credentials: true, // Allow cookies and authorization headers
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  exposedHeaders: ['RateLimit-Limit', 'RateLimit-Remaining', 'RateLimit-Reset'],
  maxAge: 86400, // Cache preflight requests for 24 hours
}));

// Security Middleware
app.use(helmet({
  crossOriginResourcePolicy: { policy: "cross-origin" }
})); // Set secure HTTP headers

// Increase JSON body size limit to allow base64 image uploads from the client.
// The frontend encodes images as data URLs; increase the limit to 10mb.
app.use(express.json({ limit: '10mb' }))
// Also parse URL-encoded bodies (forms) with the same limit
app.use(express.urlencoded({ extended: true, limit: '10mb' }))

// Rate limiting configuration
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 20, // Strict limit for auth endpoints (login/register) - 20 per 15 mins
  message: { message: 'Too many authentication attempts, please try again after 15 minutes' },
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
  handler: (req, res, next, options) => {
    res.status(429).json(options.message);
  }
});

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 500, // Limit each IP to 500 requests per 15 mins
  message: { message: 'Too many requests, please try again later' },
  standardHeaders: true,
  legacyHeaders: false,
});

// Higher limit for read-only GET requests (public data)
const readOnlyLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000, // More generous limit for read-only endpoints
  message: { message: 'Too many requests, please try again later' },
  standardHeaders: true,
  legacyHeaders: false,
});

// Simple in-memory cache for expensive aggregations
interface CacheEntry<T> {
  data: T;
  timestamp: number;
}
const cache: Map<string, CacheEntry<any>> = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes cache TTL

function getCached<T>(key: string): T | null {
  const entry = cache.get(key);
  if (entry && Date.now() - entry.timestamp < CACHE_TTL) {
    return entry.data as T;
  }
  cache.delete(key);
  return null;
}

function setCache<T>(key: string, data: T): void {
  cache.set(key, { data, timestamp: Date.now() });
}

// MongoDB Connection
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/lifebydorm');
    
    // Check if connection is successful and database is accessible
    if (mongoose.connection.readyState !== 1) {
      throw new Error('MongoDB connection not ready');
    }
    
    console.log('âœ… MongoDB connected successfully');
  } catch (error) {
    if (error instanceof Error) {
      console.error('âŒ MongoDB connection error:', error.message);
    } else {
      console.error('âŒ MongoDB connection error: Unknown error');
    }
    process.exit(1);
  }
};

// Connect to MongoDB
connectDB();

// Apply general API rate limiting to all /api routes
app.use('/api/', apiLimiter);

// ========================================
// BATCH STATS ENDPOINT - Optimized for homepage
// Returns all university and dorm statistics in a single request
// ========================================
app.get('/api/stats/homepage', readOnlyLimiter, async (req: Request, res: Response) => {
  try {
    // Check cache first
    const cacheKey = 'homepage-stats';
    const cached = getCached<any>(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    // Fetch all universities
    const universities = await University.find({}).lean();
    
    // Fetch all approved dorms
    const dorms = await Dorm.find({
      $or: [
        { status: 'approved' },
        { status: { $exists: false } }
      ]
    }).lean();

    // Fetch all approved reviews
    const reviews = await UserReview.find({
      $or: [
        { status: 'approved' },
        { status: { $exists: false } }
      ]
    }).lean();

    // Calculate university stats (review count per university)
    const universityStats: { [slug: string]: { reviewCount: number } } = {};
    universities.forEach((uni: any) => {
      universityStats[uni.slug] = { reviewCount: 0 };
    });

    // Calculate dorm stats (avg rating and review count per dorm)
    const dormStats: { [key: string]: { avgRating: number; reviewCount: number; totalRating: number } } = {};
    
    reviews.forEach((review: any) => {
      // Count for university
      if (review.university && universityStats[review.university]) {
        universityStats[review.university].reviewCount++;
      }
      
      // Calculate overall rating for dorm
      const dormKey = `${review.university}:${review.dorm}`;
      const overallRating = (review.room + review.bathroom + review.building + review.amenities + review.location) / 5;
      
      if (!dormStats[dormKey]) {
        dormStats[dormKey] = { avgRating: 0, reviewCount: 0, totalRating: 0 };
      }
      dormStats[dormKey].reviewCount++;
      dormStats[dormKey].totalRating += overallRating;
    });

    // Calculate averages for dorms
    Object.keys(dormStats).forEach(key => {
      const stat = dormStats[key];
      stat.avgRating = stat.reviewCount > 0 ? stat.totalRating / stat.reviewCount : 0;
    });

    // Prepare response with enriched data
    const enrichedUniversities = universities.map((uni: any) => ({
      ...uni,
      reviewCount: universityStats[uni.slug]?.reviewCount || 0
    }));

    const enrichedDorms = dorms.map((dorm: any) => {
      const dormKey = `${dorm.universitySlug}:${dorm.name}`;
      const stats = dormStats[dormKey] || { avgRating: 0, reviewCount: 0 };
      return {
        ...dorm,
        avgRating: stats.avgRating,
        reviewCount: stats.reviewCount
      };
    });

    // Sort and get top universities by review count
    const topUniversities = [...enrichedUniversities]
      .sort((a, b) => b.reviewCount - a.reviewCount)
      .slice(0, 7);

    // Sort and get top dorms by rating
    const topRatedDorms = [...enrichedDorms]
      .sort((a, b) => {
        if (b.avgRating === a.avgRating) return b.reviewCount - a.reviewCount;
        return b.avgRating - a.avgRating;
      })
      .slice(0, 7);

    // Sort and get most reviewed dorms
    const mostReviewedDorms = [...enrichedDorms]
      .sort((a, b) => b.reviewCount - a.reviewCount)
      .slice(0, 7);

    const result = {
      topUniversities,
      topRatedDorms,
      mostReviewedDorms,
      universityStats,
      dormStats
    };

    // Cache the result
    setCache(cacheKey, result);

    res.json(result);
  } catch (err) {
    console.error('Error fetching homepage stats', err);
    res.status(500).json({ message: 'Error fetching homepage stats' });
  }
});

// The rest of the file remains the same (routes, error handling, server start)
// To keep this patch concise the full file contents were preserved when renaming.

export default app;
